import inspect

import numpy as np


class Metric:
    """
    Metric class

    A metric is a callable object with input requirements and that pruduces output products (measures).
    """

    def __init__(self, fun, requirements=None, products=None, defaults=None):
        """
        Create a new metric

        :param fun: callable to compute the metric
        :param requirements: list of requirements
        :param products: list of outputs
        """
        self._fun = fun
        self._requirements = requirements
        if self._requirements is None:
            self._requirements = []
        self._product_labels = products
        if self._product_labels is None:
            self._product_labels = []
        self._defaults = defaults
        if self._defaults is None:
            self._defaults = dict()

        self._products = None

    def __call__(self, **kwargs):
        """
        Calls the callable

        Calls the underlying callable and return its output. Also store the products.
        """
        fun_inputs = self._get_inputs(kwargs)
        res = self._fun(**fun_inputs)
        if type(res) != tuple:
            _res = (res, )
        else:
            _res = res
        self._products = {lab: pr for lab, pr in zip(self._product_labels, _res)}
        return res

    def _get_inputs(self, kwargs):

        fun_kwargs = {}
        for r in self._requirements:
            if r in self._defaults:
                fun_kwargs[r] = self._defaults[r]
            if r in kwargs:
                fun_kwargs[r] = kwargs[r]
        return fun_kwargs

    def is_callable(self, available):
        """
        Chech if the metric is callable, given a list of available results

        :param available: list of available requirements
        :return: True if the function is callable, false otherwise
        """
        for r in self._requirements:
            if r not in available and r not in self._defaults:
                return False
        return True

    @property
    def requirements(self):
        """
        Get the requirements

        :return: list of requirements
        """
        return self._requirements

    @property
    def products(self):
        """
        Get the last products

        :return: last products generated
        """
        return self._products


def metric(*products):
    """
    Decorator to add requirements and products to a function

    This will add three properties (requirements, products and defaults) to the function,
    so that it can be passed to an Analyzer.
    Requirements and defaults are taken from the function signature.

    :param products: list of outputs
    """
    def deco(fun):
        signature = inspect.signature(fun)
        fun.requirements = list(signature.parameters.keys())
        fun.products = products
        fun.defaults = {
            k: v.default
            for k, v in signature.parameters.items()
            if v.default is not inspect.Parameter.empty
        }
        return fun

    return deco


class Analyzer:
    """
    Class that aggregate metrics and perform analysis

    This class will compute the metrics iteratively as soon as new products are generated by other metrics.
    """

    def __init__(self, *metrics):
        """
        Create an Analyzer

        :param metrics: list of Metrics (or decorated functions)
        """
        self._metrics = []
        for m in metrics:
            if type(m) is Metric:
                self._metrics.append(m)
            elif hasattr(m, "defaults"):
                self._metrics.append(Metric(m, m.requirements, m.products, m.defaults))
            else:
                self._metrics.append(Metric(m, m.requirements, m.products))
        self._last = None

    def analize(self, **current_measures):
        """
        Perform the analysis with all the metrics

        If some metrics cannot be called a RuntimeError will be thrown.

        :param current_measures: starting measures
        :return: dictionary with results of the analysis
        """
        to_call = list(range(len(self._metrics)))

        while len(to_call) > 0:

            for m in to_call:
                if self._metrics[m].is_callable(current_measures.keys()):
                    self._metrics[m](**current_measures)
                    current_measures.update(self._metrics[m].products)
                    to_call.remove(m)
                    break
            else:
                av = set(current_measures.keys())
                all_measures = []
                for m in self._metrics:
                    all_measures += m.requirements
                all_measures = set(all_measures)
                raise RuntimeError(f"Analysis failed: one among these measures cannot be produced: {all_measures - av}")

        self._last = current_measures

        return current_measures

    def __call__(self, **current_measures):
        """
        Calls analize

        :param current_measures: current_measures: starting measures
        :return: dictionary with results of the analysis
        """
        return self.analize(**current_measures)

    @property
    def last(self):
        """
        Get the last results of the analysis

        :return: last result
        """
        return self._last


######################
# begin actual metrics

@metric("discrete_positions")
def discretize_positions(continuous_positions, maze):
    """
    Metric that computes discrete positions from continuous ones

    :param continuous_positions: list of continuous
    :param maze: maze for the discretization
    :return: list of discrete positions
    """
    return maze.cont2disc_list(continuous_positions)


@metric("occupancy")
def occupancy_map(discrete_positions, maze):
    """
    Compute the occupancy map (number of visits for every tile)

    :param discrete_positions: list of discrete positions
    :param maze: maze
    :return: occupancy map
    """
    occupancy = np.zeros(maze.shape)
    for p in discrete_positions:
        occupancy[p[0], p[1]] += 1
    return occupancy


@metric("tiles_perc", "tiles_ratio", "tiles_count")
def tile_analysis(discrete_positions, maze, tiles=None):
    """
    Compute percentage, ratio and count for visited tile types

    :param discrete_positions: list of discrete positions
    :param maze: maze
    :param tiles: list of tile types to analyze
    :return: percentage by type, ratio by type, count by type
    """
    # get default tiles
    if tiles is None:
        tiles = list(maze.MazeTile)

    n_positions = len(discrete_positions)

    # count
    count = {t: 0 for t in tiles}
    for tile in discrete_positions:
        type_tile = maze.get_tile(tile)
        count[type_tile] += 1

    # perc
    perc = {t: count[t] * 100 / n_positions for t in tiles}

    # ratio
    totals = maze.description()
    ratio = {t: count[t] / totals[t] for t in tiles}

    return perc, ratio, count


@metric("orientations_histogram", "relative_orientations", "orientations_histogram_bins")
def hist_orientations(absolute_orientations, discrete_positions, n_bins=8, max_lim=np.pi * 1.125):
    """
    Compute the histogram of orientations and the relative orientation (when there is motion)

    :param absolute_orientations: list of absolute orientation
    :param discrete_positions: list of discrete positions
    :param n_bins: number of bins for the histogram
    :param max_lim: orientation corresponding to the last bin
    :return: histogram of orientations, relative orientations, bins for the histogram
    """
    if len(absolute_orientations) != len(discrete_positions):
        raise RuntimeError(f"Wrong input sizes for hist_rotations {len(absolute_orientations)} != {len(discrete_positions)}")

    min_lim = max_lim - 2 * np.pi  # ~ -2.75 by default

    relative_orientations = []
    for tim in range(0, len(absolute_orientations) - 1):
        rel_ori = absolute_orientations[tim + 1] - absolute_orientations[tim]
        if rel_ori > max_lim:
            rel_ori = rel_ori - np.pi * 2
        elif rel_ori < min_lim:
            rel_ori = rel_ori - (-np.pi * 2)

        if discrete_positions[tim + 1] != discrete_positions[tim]:
            relative_orientations.append(rel_ori)

    histogram_orientations = np.histogram(relative_orientations, bins=n_bins, range=(min_lim, max_lim))

    return histogram_orientations[0], relative_orientations, histogram_orientations[1]


@metric("count_moving", "moving_bool_list")
def motion_analysis(discrete_positions):
    """
    Compute the number of times the mouse is moving and a list of booleans indicating whether the mouse has moved
    in a certain step or not

    :param discrete_positions:
    :return: number of motions, boolean list
    """
    count_moving = 0
    moving_bool_list = [False] * len(discrete_positions)

    for i in range(1, len(discrete_positions)):
        if discrete_positions[i] != discrete_positions[i-1]:
            count_moving += 1
            moving_bool_list[i] = True
    return count_moving, moving_bool_list


@metric("histogram_time_moving")
def hist_time_moving(moving_bool_list):
    """
    Compute a histogram of move/not move actions

    Returns a list of actions (n_steps, action_type) where action_type is True if moving, False if not moving and
    n_steps is the duration of the action.

    :param moving_bool_list: boolean list of moving/not moving
    :return: list of actions
    """
    bin_mov = 1
    time_moving_histogram = []
    current_action = moving_bool_list[0]
    for t in range(1, len(moving_bool_list)):
        if moving_bool_list[t] == current_action:
            bin_mov += 1
        else:
            time_moving_histogram.append((bin_mov, int(current_action)))
            bin_mov = 1
            current_action = not current_action
    time_moving_histogram.append((bin_mov, int(current_action)))
    return time_moving_histogram


@metric("subareas_histogram")
def subareas(discrete_positions, maze):
    """
    Compute the histogram of subareas

    :param discrete_positions: list of discrete positions
    :param maze: maze
    :return: histogram of subareas
    """
    pos_subareas = maze.get_subareas(discrete_positions)
    all_subareas = maze.subareas
    min_sub = min(all_subareas)
    max_sub = max(all_subareas)
    num_subareas = max_sub - min_sub + 1
    hist_subareas = np.histogram(pos_subareas, bins=num_subareas, range=[min_sub, max_sub])
    return hist_subareas[0]


@metric("bouts_mov", "bouts_stop")
def mov_bouts(histogram_time_moving):
    """
    Compute the moving/not-moving over median bouts

    :param histogram_time_moving: list of (n_steps, action_type)
    :return: bouts moving, bouts not moving
    """
    median_period = np.median([b[0] for b in histogram_time_moving])
    mov = 0
    stop = 0
    for b in histogram_time_moving:
        if b[0] > median_period and b[1] == 1:
            mov += b[0]
        elif b[0] > median_period and b[1] == 0:
            stop += b[0]
    return mov, stop
